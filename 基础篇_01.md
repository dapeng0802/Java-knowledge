#### 001. Java 是一种面向对象的语言
#### &#8195;面向过程 VS 面向对象<br>
&#8195;&#8195;_面向过程_：把问题分解成一个个步骤，每个步骤用函数实现，一次调用即可。<br>
&#8195;&#8195;_面向对象_：将问题分解成一个个步骤，对每个步骤进行相应的抽象，形成对象，通过不同对象之间的调用，组合解决问题。<br>
#### &#8195;面向对象的基本特征<br>
&#8195;&#8195;_封装、抽象、多态、继承_<br>
#### &#8195;面向对象的基本原则<br>
&#8195;&#8195;_**单一职责原则（Single-Responsibility Principle）**_<br>
&#8195;&#8195;其核心思想为：一个类，最好只做一件事，只有一个引起它的变化。单一职责原则可以看作是低耦合、高内聚在面向对象原则上的引申，将职责定义为引起变化的原因，以提高内聚性来减少引起变化的原因。职责过多，可能引起它变化的原因就越多，这将导致职责依赖，相互之间就产生影响，从而大大损伤其内聚性和耦合度。通常意义下的单一职责，就是指只有一种单一功能，不要为类实现过多的功能点，以保证实体只有一个引起它变化的原因。<br>
&#8195;&#8195;_**开放封闭原则（Open-Closed Principle）**_<br>
&#8195;&#8195;其核心思想为：软件实体应该是可扩展的，而不可修改的，即对扩展开放，对修改封闭。对扩展开放意味着有新的需求或变化时，可以对现有代码进行扩展，以适应新的情况。对修改封闭意味着类一旦设计完成，就可以独立完成其工作，而不要对其进行任何尝试的修改。实现开放封闭原则的核心思想就是对抽象编程，而不对具体编程，因为抽象相对稳定。让类依赖于固定的抽象，所以修改是封闭的；通过面向对象的继承和多态机制，又可以实现对抽象类的继承，通过覆写其方法来改变固有行为，实现新的拓展方法，所以扩展是开放的。<br>
&#8195;&#8195;_**Liskov 替换原则（Liskov-Substitution Principle）**_<br>
&#8195;&#8195;其核心思想为：子类必须能够替换其父类。这一思想体现为对继承机制的约束规范，只有子类能够替换父类时，才能保证系统在运行期内识别子类，这是保证继承复用的基础。在父类和子类的具体行为中，必须严格把握继承层次中的关系和特征，用子类替换其父类，程序的行为不会发生任何变化。同时，这一约束反过来则是不成立的，子类可以替换父类，但父类不一定能替换子类。Liskov 替换原则主要着眼于对抽象和多态建立在继承的基础上，因此只有遵循了 Liskov 替换原则，才能保证继承复用是可靠的。实现的方法是面向接口编程：将公共部分抽象为父类接口或抽象类，通过 Extract Abstract Class，在子类中通过覆写父类的方法实现新的方式支持同样的职责。Liskov 替换原则是关于继承机制的设计原则，违反了Liskov替换原则就必然导致违反开放封闭原则。Liskov 替换原则能够保证系统具有良好的拓展性，同时实现基于多态的抽象机制，能够减少代码冗余，避免运行期的类型判别。<br>
&#8195;&#8195;_**依赖倒置原则（Dependency-Inversion Principle）**_<br>
&#8195;&#8195;其核心思想为：依赖于抽象。具体而言就是高层模块不依赖于底层模块，二者都同依赖于抽象；抽象不依赖于具体，具体依赖于抽象。当两个模块之间存在紧密的耦合关系时，最好的方法就是分离接口和实现：在依赖之间定义一个抽象的接口使得高层模块调用接口，而底层模块实现接口的定义，以此来有效控制耦合关系，达到依赖于抽象设计的目标。抽象的稳定性决定了系统的稳定性，因为抽象是不变的，依赖于抽象是面向对象设计的精髓，也是依赖导致原则的核心。<br>
&#8195;&#8195;_**接口隔离原则（Interface-Segregation Principle）**_<br>
&#8195;&#8195;其核心思想为：使用多个小的专门的接口，而不要使用一个大的总接口。具体而言，接口隔离原则体现在：接口应该是内聚的，应该避免“胖”接口。一个类对另外一个类的依赖应该建立在最小的接口上，不要强迫依赖不用的方法，这是一种接口污染。接口有效地将细节和抽象隔离，体现了对抽象编程的一切好处，接口隔离强调接口的单一性。而“胖”接口存在明显的弊端，会导致实现该接口的类必须完全实现接口的所有方法，另外，对接口的修改将导致一连串的客户端程序需要修改，有时候这是一种灾难。分离的手段主要有以下两种：1、委托分离，通过增加一个新的类来委托客户的请求，隔离客户和接口的直接依赖，但是会增加系统的开心。2、多重继承分离，通过接口多继承来实现客户的需求，这种方式较好。<br>
>你并不必严格遵守这些原则，违背它们也不会被处以宗教刑罚。但你应当把这些原则看做警铃，若违背了其中的一条，那么警铃就会响起。—— 《OOD 启示录》 ARTHUR J.RIEL
#### 002. Java VS C++
&#8195;&#8195;C++ 被设计成主要用在系统性应用程序设计上的语言，对 C 语言进行了扩展。对于 C 语言这个为运行效率设计的过程式程序设计语言，C++ 特别加上了以下这些特性的支持：静态类型的面向对象设计的支持、异常处理、RAII 以及泛型。另外它还加上了一个包含泛型容器和算法的 C++ 库函数。<br>
&#8195;&#8195;Java 最开始是被设计用来支持网络计算。它依赖一个虚拟机来保证安全和可移植性。Java 包含一个可扩展的库用以提供一个完整的下层平台的抽象。Java 是一种静态面向对象语言，它使用的语法类似 C++，但与之不兼容。<br>
&#8195;&#8195;C++ 是编译型语言（首先将源代码编译生成机器语言，再由机器运行机器码），执行速度快、效率高，依赖编译器、跨平台性差些；Java 是解释型语言（源代码不是直接翻译成机器语言，而是先翻译成中间代码，再由解释器对中间代码进行解释运行），执行速度慢、效率低，依赖解释器、跨平台性好。<br>
&#8195;&#8195;二者主要区别如下：
* C++ 是平台相关的，Java 是平台无关的。
* C++ 对所有的数字类型有标准的范围限制，但字节长度是跟具体实现相关的，不同操作系统可能不同。Java 在所有平台上对所有的基本类型都有标准的范围限制和字节长度。
* C++ 除了一些比较少见的情况之外和 C 语言兼容。Java 没有对任何之前的语言向前兼容，但在语法上受 C/C++ 的影响很大。
* C++ 允许直接调用本地的系统库。Java 要通过 JNI 调用，或者 JNA。
* C++ 允许过程式程序设计和面向对象程序设计。Java 必须使用面向对象的程序设计方式。
* C++ 支持指针、引用、传值调用。Java 只有值传递。
* C++ 需要显式的内存管理，但有第三方的框架可以提供垃圾收集的支持；支持析构函数。Java 是自动垃圾收集的；没有析构函数的概念。
* C++ 支持多重继承，包括虚拟继承。Java 只允许单继承，需要多继承的情况要使用接口。
#### 003. Java 的平台无关性
&#8195;&#8195;跨平台指的是一种语言在计算机上的运行不受平台的约束，一次编译，到处运行。平台无关有两种：源代码级和目标代码级。我们常说的跨平台，或者平台无关，指的就是目标代码，或者说是软件交付件跨平台。C 和 C++ 具有一定程度的源代码级平台无关，表明用 C 或 C++ 写的应用程序不用修改只需重新编译就可以在不同平台上运行。但是，关键是要重新编译。可是，一般软件交付都是成品，对于 C 或 C++ 开发出的软件，只能运行在某个平台，，没有源码，怎么编译。<br>
&#8195;&#8195;Java 编译出来的是字节码，到哪个平台都能用，只要有相应平台的 JDK 就可以运行，所以 Java 程序的最大优势就是平台无关。对于 Java，交付的就是一堆 jar 包或者 war 包，只要系统上有一个 Java 虚拟机，就可以直接运行，就是跨平台。<br>
&#8195;&#8195;C、C++ 以及 Java 等高级编程语言，都需要最终被编译成机器语言，才能被计算执行。C 语言和 C++ 语言的编译过程是把源代码编译生成机器语言，这样机器可以直接执行。但是不同系统对同一段“机器语言”的处理结果可能不一样，比如 CPU 的指令集不同等原因。C 语言不能实现跨平台运行，就是因为它编译出来的文件的格式，只适用于某种 CPU，其他 CPU 无法识别。Java 语言编写的源代码，经过编译后会生成一种 .class 文件，称为字节码文件，这种字节码文件需要经过 JVM 虚拟机翻译成机器语言，才能被机器执行。由于不同的操作系统上安装不同的 JVM，而 JVM 封装了所有对于 .class 文件的处理，即 JVM 帮我们把字节码翻译成机器语言的过程中就已经充分考虑到对应平台的特性了。比如，一个 .class 文件，在不同的机器上最终生成的机器语言可能是不同的，但是这种不同不需要我们关心，JVM 会保证它可以正常运行，完整的表达正确的程序语义。
#### 004. Java 的值传递
#### &#8195;&#8195;实参与形参
&#8195;&#8195;_形式参数_：是在定义函数名和函数体的时候使用的参数，目的是用来接收调用该函数时传入的参数。<br>
&#8195;&#8195;_实际参数_：在调用有参函数时，主调函数和被调函数之间有数据传递关系。在主调函数中调用一个函数时，函数名后面括号中的参数称为实际参数。
#### &#8195;&#8195;值传递与引用传递
&#8195;&#8195;_值传递（pass by value）_：是指在调用函数时将实际参数复制一份传递到函数中，这样在函数中如果对参数进行修改，将不会影响到实际参数。<br>
&#8195;&#8195;_引用传递（pass by reference）_：是指在调用函数时将实际参数的地址直接传递到函数中，那么在函数中对参数所进行的修改，将影响到时间参数。<br> 
#### &#8195;&#8195;Java 中的值传递
&#8195;&#8195;对于基本数据类型，把实际参数本身复制了一个副本传递给形式参数；对于对象，把实际参数的引用的地址复制了一个副本传递给形式参数。因此，Java 中是值传递，只不过对于对象参数，值的内容是对象的引用。<br>
&#8195;&#8195;无论是值传递还是引用传递，其实都是一种求值策略（Evaluation strategy）。在求值策略中，还有一种叫做按*共享传递（call by sharing）*。其实 Java 中的参数传递严格意义上说应该是按共享传递。
>&#8195;&#8195;按共享传递，是指在调用函数时，传递给函数的是实参的地址的拷贝（如果实参在栈中，则直接拷贝该值）。在函数内部对参数进行操作时，需要先根据拷贝的地址寻找到具体的值，再进行操作。如果该值在栈中，那么因为是直接拷贝的值，所以函数内部对参数进行操作不会对外部变量产生影响。如果原来拷贝的是原值在堆中的地址，那么需要先根据拷贝的地址寻找到具体的值，再进行操作。因为传递的是地址的拷贝，所以函数内对值的操作对外部变量是可见的。
#### &#8195;&#8195;按共享传递其实只是按值传递的一个特例，所以 Java 的传递是按共享传递，或者说 Java 中的传递是值传递。
#### 005. Java 的编译和反编译
&#8195;&#8195;编译就是将高级语言转换成低级语言的过程。机器语言和汇编语言属于低级语言，直接用计算机指令编写程序；C、C++、Java、Python 等属于高级语言，用语句（Statement）编写程序，语句是计算机指令的抽象表示。编译是将便于人类编写、阅读、维护的高级计算机语言所写作的源代码程序翻译为计算机能解读、运行的低级机器语言的程序的过程，负责这一过程的处理工具叫做编译器。<br>
&#8195;&#8195;反编译的过程与编译刚好相反，就是将已编译好的编程语言还原到未编译的状态，也就是找出程序语言的源代码，将机器看得懂的语言转换成程序员可以看得懂的语言。<br>
&#8195;&#8195;Java 语言中负责编译的编译器是一个命令：javac，javac 是收录于 JDK 中的 Java 语言编译器，该工具可以将后缀名为 .java 的源文件编译为后缀名为 .class 的可以运行于 JVM 的字节码。其实 .class 文件仍然不是机器能够识别的语言，还需要 JVM 再将 .class 文件类型的字节码转换成机器可以识别的机器语言。Java 语言中的反编译一般指将 .class 文件转换成 .java 文件，Java 中反编译工具如 javap、jad、CRF 等。
#### 006. Java 的语法糖
&#8195;&#8195;_**语法糖（Syntactic Sugar）**_，也称糖衣语法，是由英国计算机学家 Peter.J.Landin 发明的一个术语，指在计算机语言中添加的某种语法，这种语法对语言的功能并没有影响，但是更方便程序员使用。简而言之，语法糖让程序员更加简洁，有更高的可读性。但是，JVM 并不支持这些语法糖，在编译阶段这些语法糖会被还原成简单的基础语法结构，这个过程就是 _**解语法糖**_。com.sun.tools.javac.main.JavaCompiler 的源码中，在 compile() 中有一个步骤就是调用 desugar()，这个方法就是负责解语法糖的实现的。Java 中最常用的语法糖主要有泛型、变长参数、条件编译、自动拆装箱、内部类等。<br>
- 糖块一、switch 支持 String <br>
&#8195;&#8195;Java 中的 swith 自身只支持基本类型，如 int、char 等。对于 int 类型，直接进行数值的比较；对于 char 类型则是比较其 ascii 码。所以，对于编译器来说，switch 中其实只能使用整型，其他类型的比较都要转换成整型。Java 7 中 switch 开始支持 String，通过反编译可以发现，switch 比较实际是 String 的 hashCode() 方法来实现的，然后通过使用 equals() 方法比较进行安全检查，以防哈希碰撞。
- 糖块二、泛型 <br>
&#8195;&#8195;很多编程语言都支持泛型，但不同的编译器对于泛型的处理方式是不同的，通常，编译器处理泛型的方式有两种：Code specialization 和 Code sharing。C++ 和 C# 使用的是 Code specialization 处理机制，Java 使用的是 Code sharing 处理机制。Code sharing 方式为每个泛型类型创建唯一的字节码表示，并且将该泛型类型的实例都映射到这个唯一的字节码表示上，通过类型擦除（type erasure）实现的。也就是说，对于 JVM 来说，根本不认识 Map<String, String> map 这样的语法，需要在编译阶段通过类型擦除的方式进行解语法糖。<br>
&#8195;&#8195;类型擦除的主要过程如下：将所有的泛型参数用其最左边界（最顶级的父类型）类型替换，擦除所有的类型参数，比如，Map<String, String> map = new HashMap<String, String>(); 解语法糖后会变成 Map map = new HashMap();。JVM 中没有泛型，只有普通类和普通方法，所有泛型类的类型参数在编译时都会被擦除，泛型类并没有自己独有的 Class 类对象。比如并不存在 List<String>.class 或是 List<Integer>.class，而只有 List.class。
- 糖块三、自动拆箱与装箱 <br>
&#8195;&#8195;自动装箱就是 Java 自动将原始数据类型值转换成对应的包装类对象，比如将 int 的变量转换成 Integer 对象，这个过程叫做装箱，反之将 Integer 对象转换成 int 类型值的过程叫做拆箱。装箱的过程是通过调用包装器的 valueOf 方法实现的，拆箱的过程是通过调用包装器的 xxxValue 方法实现的。
- 糖块四、方法变长参数 <br>
&#8195;&#8195;可变参数（variable arguments）是在 JDK 1.5 中引入的一个特性，它允许一个方法把任意数量的值作为参数。可变参数在被使用时，会首先创建一个数组，数组的长度就是调用该方法时传递的实参的个数，然后再把参数值全部放到这个数组当中，再把这个数组作为参数传递到被调用的方法中。
- 糖块五、枚举 <br>
&#8195;&#8195;JDK 1.5 提供了一种新的类型——Java 的枚举类型，关键字 enum 可以将一组具名的值的有限集合创建为一种新的类型，而这些具名的值可以作为常规的程序组件使用，这是一个非常有用的功能。当使用 enum 来定义一个枚举类型时，编译器会自动创建一个 final 类型的继承自 Enum 类的类，所以枚举类型不能被继承。
- 糖块六、内部类 <br>
&#8195;&#8195;内部类又称为嵌套类，可以把内部类理解为外部类的一个普通成员。内部类之所以也是语法糖，是因为它仅仅是一个编译时的概念，outer.java 里面定义了一个内部类 inner，一旦编译成功，就会生成两个完全不同的 .class 文件了，分别是 outer.class 和 outer$inner.class。所以内部类的名字完全可以和它的外部类名字相同。
- 糖块七、条件编译 <br>
&#8195;&#8195;一般情况下，程序中的每一行代码都要参加编译，但有时候出于对程序代码优化的考虑，希望只对其中一部分内容进行编译，此时就需要在程序中加上条件，让编译器只对满足条件的代码进行编译，将不满足条件的代码舍弃，这就是条件编译。Java 语法的条件编译，是通过判断条件为常量的 if 语句实现的，根据 if 判断条件的真假，编译器直接把分支为 false 的代码块消除。通过该方法实现的条件编译，必须在方法体内实现，而无法在整个 Java 类的结构或者类的属性上进行条件编译，这与 C/C++ 的条件编译（C/C++ 中可以通过预处理语句来实现条件编译）相比，确实更有局限性。在 Java 语言设计之初并没有引入条件编译的功能，虽然有局限性，但总比没有强。
- 糖块八、断言 <br>
&#8195;&#8195;在 Java 中，assert 关键字是从 JDK 1.4 引入的，为了避免在老版本的 Java 代码中使用了 assert 关键字导致错误，Java 在执行的时候默认是不启动断言检查的，如果要开启断言检查，则需要用 -enableassertion 或 -ea 来开启。其实断言的底层就是 if 语言，如果断言结果为 true 则什么也不做，程序继续执行；如果断言结果为 false 则程序抛出 AssertError 来打断程序的执行。-enableassertions 会设置 $assertionsDisabled 字段的值。
- 糖块九、数值字面量 <br>
&#8195;&#8195;在 JDK 1.7 中，数值字面量不管是整数还是浮点数，都允许在数字之间插入任意多个下划线，这些下划线不会对字面量的数值产生影响，目的就是方便阅读，如 10_000，反编译后就是 10000。也就是说 JVM 并不认识数字字面量中的“_”，需要在编译阶段将其去掉。
- 糖块十、for-each <br>
&#8195;&#8195;增强型 for 循环（for-each）这个语法糖经常会用到，其实现原理是使用了普通的 for 循环和迭代器。
- 糖块十一、try-with-resource <br>
&#8195;&#8195;Java 里对于文件操作 IO 流、数据库连接等开销非常昂贵的资源，用完之后必须及时通过 close 方法将其关闭，否则资源会一致处于打开状态，可能会导致内存泄漏等问题。关闭资源的常用方式是在 finally 块里调用 close 方法释放资源。从 JDK 1.7 开始，Java 提供了一种更好的方式关闭资源，即使用 try-whit-resources 语句，形如 try(File file = new File(fileName))，这种新的语法糖看上去很优雅，但其背后的原理也很简单，那些我们没有做的关闭资源的操作，编译器都帮我们做了。
#### 007. Java 8 中的 lambda 表达式
&#8195;&#8195;Java 8 中最重要的特征之一就是 lambda 表达式，它可以让我们用简洁流畅的代码完成一个功能。lambda 表达式是一段可以传递的代码，它的核心思想是将面向对象中的传递数据变成传递行为。在 lambda 中遵循如下的表达式来编写：expression = (variable) -> action。variable 是一个变量，一个占位符，像 x,y,z 可以是多个变量；action 是实现的代码逻辑部分，它可以是一行代码，也可以是一个代码片段。<br>
&#8195;&#8195;lambda 表达式也是 Java 的一个语法糖，实现方式其实是依赖了几个 JVM 底层提供的 lambda 相关 API，在编译阶段，编译器会把 lambda 表达式进行解糖，转换成调用内部 API 的方式。
#### 008. Java 中的多态
&#8195;&#8195;多态的概念比较简单，就是同一操作用于不同的对象，可以有不同的解释，产生不同的执行结果。如果按照这个概念来定义的话，那么多态应该是一种运行期的状态，为了实现运行期的多态，或者说是动态绑定，需要满足三个条件：有类继承或者接口实现、子类要重写父类的方法、父类的引用指向子类的对象。<br>
&#8195;&#8195;另外还有一种说法，包括[维基百科](https://en.wikipedia.org/wiki/Polymorphism_(computer_science))也说明，多态还分为动态多态和静态多态。上面提到的动态绑定认为是动态多态，因为只有在运行期才能知道真正调用的是哪个类的方法。还有一种静态多态，一般认为 Java 中的函数重载是一种静态多态，因为它需要在编译期决定具体调用哪个方法。但对于重载是一种静态多态的这种说法，网上有很多讨论，并未有定论。
#### 009. Overloading VS Override
&#8195;&#8195;Overloading（重载）和 Override（重写）是 Java 中两个比较重要的概念。重载就是函数或者方法有同意的名称，但是参数列表不相同的情形，这样的同名不同参数的函数或者方法之间，互相称之为重载函数或者方法。重写指的是在 Java 的子类与父类中有两个名称、参数列表都相同的方法的情况，由于他们具有相同的方法签名，所以子类中的新方法将覆盖父类中原有的方法。关于重载和重写，需要注意如下几点：
1. 重载是一个编译期的概念，重写是一个运行期的概念。
2. 重载遵循所谓“编译期绑定”，即在编译时根据参数变量的类型判断应该调用哪个方法。
3. 重写遵循所谓“运行期绑定”，即在运行的时候根据引用变量所指向的实际对象的类型来调用方法。
4. 因为在编译期已经确定调用哪个方法，所以重载并不是多态。而重写是多态。重载只是一种语言特性，是一种语法规则，与多态无关，与面向对象也无关。（注：严格来说，重载是编译时多态，即静态多态，但是 Java 中提到的多态，在不特别说明的情况下都指动态多态）<br>
&#8195;&#8195;重写指的是方法，并没有提到成员变量。在一个类中，子类中的成员变量如果和父类中的成员变量同名，那么即使他们类型不一样，只要名字一样，父类中的成员变量就会被隐藏。在子类中，父类的成员变量不能被简单地用引用来访问，而是必须从父类的引用获得父类被隐藏的成员变量。
#### 010. 接口 VS 抽象类
&#8195;&#8195;接口和抽象类，最明显的区别就是接口只是定义了一些方法而已，在不考虑 Java 8 中 default 方法情况下，接口中是没有实现的代码的。抽象类中的抽象方法可以有 public、protected 和 default 这些修饰符，而接口中默认修饰符是 public，不可以使用其他修饰符。通常把接口暴露给外部，然后在业务代码中实现接口，如果多个实现类中有相同可复用的代码，则在接口和实现类中间加一层抽象类，将公用部分代码抽出到抽象类中。可以参考模板方法设计模式。

