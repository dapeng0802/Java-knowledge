#### 016. Java 中的基本数据类型
&#8195;&#8195;Java 中有 8 中基本数据类型，分为三大类。
  - 字符型：char
  - 布尔型：boolean
  - 数值型：
    * 整型：byte、short、int、long
    * 浮点型：float、double
  
&#8195;&#8195;整型的几个类型中：
- byte：用 1 个字节存储，范围为 -128(-2^7)~127(2^7-1)，变量初始化的时候，默认值为 0
- short：用 2 个字节存储，范围为 -32,768(-2^15)~32767(2^15-1)，变量初始化的时候，默认值为 0
- int：用 4 个字节存储，范围为 -2,147,483,648(-2^31)~2,147,438,647(2^31-1)，变量初始化的时候，默认值为 0
- long：用 8 个字节存储，范围为 -9,223,372,036,854,775,808(-2^63)~9,223,372,036,854,775,807(2^63-1)，变量初始化的时候，默认值为 0L 或 0l，也可直接写为 0

&#8195;&#8195;浮点数（floating-point number）是在计算机科学中的一种对于实数的近似值数值表现法，由一个有效数字（即尾数）加上幂数来表示，通常是乘以某个基数的整数次指数得到。位（bit）是衡量浮点数所需存储空间的单位，通常为 32 位或 64 位，分别叫做单精度和双精度。单精度浮点数（float）在计算机存储器中占用 4 个字节（32 bits），双精度浮点数（double）使用 8 个字节（64 bits）来存储一个浮点数。由于浮点数表示的是近似值，并不是精确值，千万不要用来表示金额等重要指标，建议使用 BigDecimal 或者 Long（单位为分）来表示。

&#8195;&#8195;Java 中的 char 占用 2 个字节。中文使用 Unicode 编码，同样占用 2 个字节，因此，只要在 Unicode 编码中有的中文，即可用 char 存储，生僻字和特殊字除外。

&#8195;&#8195;String 不是基本数据类型，是引用类型。
#### 017. 基本数据类型与包装类之间的区别
- 默认值不同：基本数据类型为 0、false 或 \u0000，包装类默认为 null。
- 初始化不同：包装类需要 new（也可以自动装箱），基本数据类型不需要。
- 存储方式不同
- int.class 是原始类型，Integer.class 是对象类型，所以一个有成员变量和方法，一个没有。
#### 018. 自动装箱与自动拆箱
&#8195;&#8195;自动装箱是指 Java 自动将基本数据类型的值转换为对应的包装器类型对象，比如将 int 的变量转换成 Integer 对象。反之，Java 自动将包装器类型对象转换为对应基本数据类型的值的过程是自动拆箱。装箱是通过调用包装器类的`valueOf`方法实现，拆箱是通过调用包装器类的`xxxValue`方法实现。
#### 019. 接口定义时，定义一个字段表示是否成功，应该用以下哪种方式？
- boolean success
- Boolean success
- boolean isSuccess
- Boolean isSuccess

&#8195;&#8195;应该使用第一种方式。首先，作为接口的返回对象的参数，这个字段不应该有不确定的 null 值，而 Boolean 类型的默认值是 null，boolean 的默认值是 false，所以应该用 boolean 来定义参数。其次，关于参数名称，是使用 success 还是 isSuccess，这一点在阿里巴巴 Java 开发手册中有明确的规定和解释：
> 【强制】 POJO 类中布尔类型的变量都不要加 is 前缀，否则部分框架解析会引起序列化错误。<br>
反例：定义为基本数据类型 boolean isDeleted; 的属性，它的方法也是 isDeleted()，RPC 框架在反向解析的时候，“误以为”对应的属性名称是 deleted，导致属性获取不到，进而抛出异常。
#### 020. String s = new String("hello"); 定义了几个对象？
&#8195;&#8195;字符串的分配，和其他对象分配一样，耗费高昂的时间与空间代价。JVM 为了提高性能和减少内存开销，在实例化字符串常量的时候进行了一些优化。为了减少在 JVM 中创建的字符串的数量，字符串类维护了一个字符串池，每当代码创建字符串常量时，JVM 会首先检查字符串常量池。如果字符串已经存在池中，就返回池中的实例引用；如果字符串不在池中，就会实例化一个字符串并放入到池中。Java 能够进行这样的优化是因为字符串是不可变的，可以不用担心数据冲突进行共享。

&#8195;&#8195;`String s = new String("hello"); `定义了多少个对象？在常量池中查找是否有`"hello"`对象，有则返回对应的引用实例，没有则创建对应的实例对象，在堆中`new`一个`String("hello")`对象，将对象地址赋值给`s`，创建一个引用。所以，常量池中没有`"hello"`字面量则创建两个对象，否则创建一个对象，以及创建一个引用。
#### 021. 字符串比较
&#8195;&#8195;对于字符串的比较，一般目的是比较字符串的内容是否相同，这种情况下，要使用`equals()`方法来比较，而不是使用`==`。`equals()` 比较的是内容是否相同，`==`比较的是地址是否相同。
#### 022. String 有没有长度限制
&#8195;&#8195;**编译期**

&#8195;&#8195;当使用`String s = "";`的形式定义 String 对象时，如果字符串超过 65534 个字符，会在编译期报错。这是因为，当使用字符串字面量直接定义 String 的时候，是会把字符串在常量池中存储一份的，65534 其实是常量池的限制。常量池中的每一种数据项也有自己的类型。Java 中 UTF-8 编码的 Unicode 字符串在常量池中以`CONSTANT_Utf8`类型表示。`CONSTANT_Utf8_info`是一个`CONSTANT_Utf8`类型的常量池数据项，它存储的是一个常量池字符串。常量池中的所有字面量几乎都是通过`CONSTANT_Utf8_info`描述的。`CONSTANT_Utf8_info`的定义如下：
```
CONSTANT_Utf8_info {
    u1 tag;
    u2 length;
    u1 bytes[length];
}
```
&#8195;&#8195;其中的`u2 length;`表明了该类型存储数据的长度，`u2`是无符号的 16 位整数，因此理论上允许的最大长度是`2^16 = 65536`。而 Java 的 class 文件是使用一种变体 UTF-8 格式来存放字符的，`null`值使用 2 个字节来表示，因此只剩下`65536 - 2 = 65534`个字节。因此，在 Java 中，所有需要保存在常量池中的数据，长度最大不能超过 65535，这当然也包括字符串的定义。

&#8195;&#8195;**运行期**

&#8195;&#8195;在运行期，根据 String 源码`public String(char value[], int offset, int count)`的定义，`count`是 int 类型的，所以`char value[]`中最多可以保存`Integer.MAX_VALUE`个字符，即 2,147,483,647 个字符。这个值约等于 4G，在运行期如果 String 的长度超过这个范围，就可能会抛出异常。
```
2^31 - 1 = 2147483647 个 char
2147483647 * 2 = 4294967294 个字节（每个 char 占 2 个字节）
4294967294 / 1024 / 1024 / 1024 = 3.99999 GB，约 4G 的容量
```
#### 023. String 的 “+” 是如何实现的
&#8195;&#8195;对于`String s = "a" + "b";`方式，编译器会进行常量折叠，即变成`String s = "ab";`。对于`String s = 'a' + 变量`方式，编译器用`StringBuilder`的`append()`方法替代，最后调用`toString()`方法。
#### 024. String、StringBuider 和 StringBuffer
&#8195;&#8195;
