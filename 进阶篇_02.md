#### 104. Java 字节码
&#8195;&#8195;为了让 Java 语言具有良好的跨平台能力，Java 独具匠心地提供了一种可以在所有平台上都能使用的一种中间代码——字节码（ByteCode）。有了字节码，无论哪种平台，只要安装了平台对应的 Java 虚拟机，都可以直接运行字节码。同样，有了字节码，也解除了 Java 虚拟机和 Java 语言之间的耦合。目前 Java 虚拟机已经可以支持很多 Java 语言之外的语言了，如 Kotlin、Groovy、JRuby、Jython、Scala 等，这些语言也可以被编译成字节码，而虚拟机并不关心字节码是哪种语言编译而来的，只要字节码符合 Java 虚拟机的格式规范都可以运行。

&#8195;&#8195;为了方便 Java 虚拟机识别一个文件是否是 class 类型的文件，SUN 公司规定每个 class 文件都必须以一个 word（四个字节）作为文件开始，这个数字就是魔数。魔数是由四个字节的无符号数组成的，用以识别一个文件类型，class 文件的魔数是`0xCAFEBABE`。在有些代码中，存在一些数字常量或字符串，没有注释，并且从命名上也看不出其意义，这样的常量或字符串也称为魔数，这样的魔数不仅使代码的可读性大大降低，还可能存在潜在的问题，所以在代码中要尽量避免魔数，可以用枚举或静态变量代替。
#### 105. Java 编译与反编译
&#8195;&#8195;将便于人编写、阅读、维护的高级计算机语言所写作的源代码程序，翻译为计算机能解读、运行的低阶机器语言的程序的过程就是编译，负责这一过程的处理工具叫做编译器。Java 语言中负责编译的编译器是`javac`命令，收录于 JDK 中， 其可将后缀名为`.java`的源文件编译为后缀名为`.class`的可以运行于 JVM 的字节码文件，由 JVM 再将`.class`文件类型的字节码解释成机器可以识别的机器语言。反编译的过程与编译相反，将已编译好的编程语言还原到未编译的状态，也就是程序语言的源代码。Java 语言中的反编译一般指将`.class`文件转换成`.java`文件，`javap`是 JDK 自带的反编译工具，可以对代码反编译，也可以查看 Java 编译器生成的字节码。此外，jad 和 cfr 也不错的第三方反编译工具。为了保护源文件，不被攻击者轻易通过反编译获得未开源的源文件，可以通过隔离 Java 程序、对`class`文件加密、代码混淆等手段提高攻击者成本，但无法彻底防治。
#### 106. JIT 编译器
&#8195;&#8195;JIT 编译器，即 Just-In-Time 编译，译为即时编译器，使用即时编译器技术可以加速 Java 程序的执行速度。通常通过`javac`将程序源代码编译为字节码，JVM 通过解释字节码将其翻译成对应的机器指令，逐条读入，逐条解释翻译。解释执行的执行速度必然比可执行的二进制字节码程序慢很多，为了提高执行速度，引入了 JIT 技术。在运行时 JIT 会把翻译过的机器码保存起来，以备下次使用，因此从理论上来说，采用 JIT 技术可以接近纯编译技术。

&#8195;&#8195;JVM 发现某个方法或代码块运行特别频繁的时候，就会认为这是热点代码（Hot Spot Code），然后 JIT 会把部分热点代码翻译成本地机器相关的机器码，并进行优化，然后再把翻译后的机器码缓存起来，以备下次使用。HotSpot 虚拟机中内置了两个 JIT 编译器：Client Compiler 和 Server Compiler，分别用在客户端和服务端，目前主流的 HotSpot 虚拟机中默认是采用解释器与其中一个编译器直接配合的方式工作。
#### 107. Java 逃逸分析
&#8195;&#8195;逃逸分析的基本行为就是分析对象动态作用域，当一个对象在方法中被定义后，它可能被外部方法所引用，例如作为调用参数传递到其他地方，称为方法逃逸。使用逃逸分析，编译器可以对代码做如下优化：
- 同步省略：在动态编译同步块的时候，JIT 编译器可以借助逃逸分析来判断同步块所使用的锁对象是否只能被一个线程访问而没有被发布到其他线程。如果同步块所使用的锁对象通过这种分析被证实只能够被一个线程访问，那么 JIT 编译器在编译这个同步块的时候就会取消对这部分代码块的同步，这个取消同步的过程就叫同步省略，也叫锁消除。
- 标量替换：标量（Scalar）是指一个无法再分解成更小的数据的数据。Java 中的原始数据类型就是标量。相对的，那些还可以分解的数据叫做聚合量（Aggregate），Java 中的对象就是聚合量，可以分解为其他的聚合量和标量。在 JIT 阶段，如果经过逃逸分析，发现一个对象不会被外界访问的话，那么经过 JIT 优化，就会把这个对象拆解成若干个其所包含的成员变量来代替，这个过程就是标量替换。这样可以减少堆内存的占用，因为不需要创建对象就不需要分配堆内存了。
- 栈上分配：JVM 中，对象是在 Java 堆中分配内存的，如果经过逃逸分析后发现，一个对象没有逃逸出方法的话，那么就可能被优化成栈上分配，这样无须在堆上分配内存，也就无须进行垃圾回收了。但是，现有的 JVM 中，还没有真正实现栈上分配。

&#8195;&#8195;逃逸分析并不成熟，因为无法保证逃逸分析所优化的性能消耗一定高于分析自身的消耗，虽然经过逃逸分析可以做标量替换、栈上分配和锁消除，但逃逸分析自身也需要进行一系列复杂的分析，也是一个相对耗时的过程。虽然这项技术并不十分成熟，但它也是即时编译器优化技术的一个十分重要的手段。在 Java 代码运行时，通过 JVM 参数可指定是否开启逃逸分析。`-XX:+DoEscapeAnalysis`表示开启逃逸分析，`-XX:-DoEscapeAnalysis`表示关闭逃逸分析，从 JDK 1.7 开始已经默认开启逃逸分析。
#### 107. Java 中的正则表达式
&#8195;&#8195;`java.util.regex`包主要包括以下三个类：
- `Pattern`类：`Pattern`类的对象是一个正则表达式的编译表示，`Pattern`类没有公共构造方法，要创建一个`Pattern`对象，必须首先调用其公共静态编译方法，返回一个`Pattern`对象。该方法接受一个正则表达式作为它的第一个参数。
- `Matcher`类：`Matcher`类的对象是对输入字符串进行解释和匹配操作的引擎，`Matcher`类也没有公共构造方法，需要调用`Pattern`对象的`matcher`方法来获得一个`Matcher`对象。
- `PatternSyntaxException`类：`PatternSyntaxException`是一个非强制异常类，表示一个正则表达式模式中的语法错误。
#### 108. Java 中常用的第三方类库
&#8195;&#8195;Java 的日常开发中，常用的第三方类库有`commons.lang`、`commons.*`、`guava-libraries`、`netty`等。
#### 109. 什么是函数式编程
&#8195;&#8195;函数式编程是一种编程方式，它将计算机运算视为函数的计算。函数编程语言最重要的基础是 λ 演算（lambda calculus），而且 λ 演算的函数可以接受函数作为输入（参数）和输出（返回值）。比起指令式编程，函数式编程更加强调程序执行的结果而非执行的过程，倡导利用若干简单的执行单元让计算结果不断渐进，逐层推导复杂的运算，而不是设计一个复杂的执行过程。它属于结构化编程的一种，主要思想是把运算过程尽量写成一系列嵌套的函数调用。
#### 110. Java 的`lambda`表达式 
&#8195;&#8195;`lambda`表达式是推动 JDK 1.8 发布的最重要的新特性。`lambda`允许把函数作为一个方法参数传递进方法中，使用`lambda`表达式可以使代码变得更加简洁紧凑。`lambda`表达式的语法格式如下：`(parameters) -> expression`或`(parameters) -> { statements; }`。`lambda`表达式具有以下重要特征：
- 可选参数声明：不需要声明参数类型，编译器可以统一识别参数值。
- 可选的参数圆括号：一个参数无须定义圆括号，但多个参数需要定义圆括号。
- 可选的大括号：如果主体包含了一条语句，就不需要使用大括号。
- 可选的返回关键字：如果主体只有一个表达式返回值则编译器会自动返回值，大括号需要指定明确表达式返回了一个数值。
#### 111. `Stream`
&#8195;&#8195;`Stream`作为 JDK 1.8 的一大亮点，它与`java.io`包里的`InputStream`和`OutputStream`是完全不同的概念。JDK 1.8 中的`Stream`是对集合（`Collection`）对象功能的增强，它专注于对集合对象进行各种非常便利、高效的聚合操作（aggregate operation），或者大批量数据操作（bulk data operation）。`Stream`借助于同样新出现的`lambda`表达式，极大的提高编程效率和程序可读性，同时它提供串行和并行两种模式进行汇聚操作，并发模式能够充分利用多核处理器的优势，使用`fork/join`并行方式来拆分任务和加速处理过程。

&#8195;&#8195;`Stream`就如同一个迭代器（`Iterator`），单向、不可往复，数据只能遍历一次，而和迭代器又不同的是，`Stream`可以并行化操作。当使用一个`Stream`的时候，通常包括三个基本步骤：获取一个数据流（source）-> 数据转换 -> 执行操作获取结果，每次转换原有`Stream`对象不改变，返回一个新的`Stream`对象（可以有多次转换）。有多种方式生成`Stream Source`：
- 从`Collection`和数组
  - `Collection.stream()`
  - `Collection.parallelStream()`
  - `Arrays.stream(T array) or Stream.of()`
- 从`BufferedReader`
  - `java.io.BufferedReader.lines()`
- 静态工厂
  - `java.util.stream.IntStream.range()`
  - `java.nio.file.Files.walk()`
- 自己构建
  - `java.util.Spliterator`
- 其它
  - `Random.ints()`
  - `BitSet.stream()`
  - `Pattern.splitAsStream(java.lang.CharSequence)`
  - `JarFile.stream()`

&#8195;&#8195;`Stream`的操作类型分为三种：
- `Intermediate`：一个`Stream`后面可以跟随零个或多个`intermediate`操作，其目的主要是打开`Stream`，进行某种程度的数据映射或过滤，然后返回一个新的`Stream`，交给下一个操作使用。这些操作都是惰性化的（lazy），仅仅调用到这类方法，并没有真正开始遍历。具体操作有：`map, mapToInt, flatMap, filter, distinct, sorted, peek, limit, skip, parallel, sequential, unordered`。
- `Terminal`：一个`Stream`只能有一个`terminal`操作，当这个操作执行后，`Stream`就用“光”了，无法再被操作，所以这必定是`Stream`的最后一个操作。`terminal`操作的执行，才会真正开始`Stream`的遍历，并且会生成一个结果或者一个`side effect`。具体操作有：`forEach, forEachOrdered, toArray, reduce, collect, min, max, count, anyMatch, allMatch, noneMatch, findFirst, findAny, iterator`。
- `short-circuiting`：对于一个`intermediate`操作，如果它接受一个无限大（infinite/unbounded）的`Stream`，返回一个有限的新`Stream`；对于一个`terminal`操作，如果它接受一个无限大的`Stream`，能在有限时间计算出结果。具体操作有：`anyMatch, allMatch, noneMatch, findFirst, findAny, limit`。

&#8195;&#8195;对于基本数值型，目前有三种对应的包装类型`Stream`：`IntStream, LongStream, DoubleStream`。当然也可以用`Stream<Integer>, Stream<Long>, Stream<Double>`，但`boxing`和`unboxing`会很耗时，所以特别为这三种基本数值型提供了对应的`Stream`。

&#8195;&#8195;通过实现`Supplier`接口，可以自己控制`Stream`的生成，常用于随机数、常量的`Stream`，或者前后元素间维持着某种状态信息的`Stream`。把`Supplier`实例传递给`Stream.generate()`生成的`Stream`，默认是串行但无序的，由于它是无限的，必须利用`limit`之类的操作限制`Stream`大小。还可以通过`Stream.iterate`的方式生成`Stream`，`iterate`和`reduce`很像，接受一个种子值，和一个`UnaryOperator`，例如`f`，然后种子值成为`Stream`的第一个元素，`f(seed)`为第二个，`f(f(seed))`为三个，以此类推，`iterate`同样必须有`limit`这样的操作来限制`Stream`大小。
#### 112. 并发 VS 并行
&#8195;&#8195;
&#8195;&#8195;
