#### 053. `Throwable`
&#8195;&#8195;`Throwable`是 Java 中最顶级的异常类，继承`Object`类，实现了序列化接口，有两个重要的子类`Exception`和`Error`，二者都是 Java 异常处理的重要子类，各自都包含大量的子类。`Error`表示系统级的错误，是 Java 运行环境内部错误或者硬件问题，程序无法处理这样的问题，只能退出运行，它是 JVM 抛出的。`Exception` 表示程序需要捕捉、需要处理的异常，是由于程序设计不完善而出现的问题，必须由程序处理。
![Throwable 结构图](https://pic4.zhimg.com/80/v2-588db8a3209e2c51e3e2c88b6d7e7c83_hd.jpg)
#### 054. `Exception`
&#8195;&#8195;Java 中的`Exception`主要分为两大类，即`checked exception`（受检异常）和`unchecked exception`（非受检异常）。
- 对于受检异常来说，如果一个方法在其声明中指明了其要有受检异常抛出：`public void test() throws IOException {}`，那么调用这个方法时，一定要对该异常进行处理（捕获或者向上抛出），否则是无法编译通过的，这是一种强制规范。这种异常在 IO 操作中比较多，比如`FileNotFoundException`。所以，当希望方法的调用者明确处理一些特殊情况的时候，就应该使用受检异常。
- 对于非受检异常来说，一般是运行时异常，继承自`RuntimeException`。在编写代码的时候不需要显式地捕获，但是如果不捕获，在运行期如果发生异常就会中断程序的执行。这种异常一般可以理解为是代码原因导致的，比如发生空指针、数组越界等，所以，只有代码写的没问题，这些异常是可以避免的，也就不需要我们显式进行处理。
#### 055. 常见的`RuntimeException`
&#8195;&#8195;`AnnotationTypeMismatchException` `ArithmeticException` `ArrayStoreException` `BufferOverflowException` `BufferUnderflowException` `CannotRedoException` `CannotUndoException` `ClassCastException` `CMMException` `ConcurrentModificationException` `DataBindingException` `DOMException` `EmptyStackException` `EnumConstantNotPresentException` `EventException` `FileSystemAlreadyExistsException` `FileSystemNotFoundExceptoin` `IllegalArgumentException` `IllegalMonitorStateException` `IllegalPathStateException` `IllegalStateException` `IllformedLocaleException` `ImagingOpException` `IncompleteAnnotationException` `IndexOutOfBoundsException` `JMRuntimeException` `LSException` `MalformedParameterizedTypeException` `MirroredTypesException` `MissingResourceException` `NegativeArraySizeException` `NoSuchElementException` `NoSuchMechanismException` `NullPointerException` `ProfileDataException` `ProviderException` `ProviderNotFoundException` `RasterFormatException` `RejectedExecutionException` `SecurityException` `SystemException` `TypeConstraintException` `TypeNotPresentException` `UndeclaredThrowableException` `UnknownEntityException` `UnmodifiableSetException` `UnsupportedOperationException` `WebServiceException` `WrongMethodTypeException`
#### 056. 捕获异常后应该做什么？
&#8195;&#8195;常见的处理方法有：记录日志、封装异常重新抛出、忽略异常、处理后正常返回。其中最不可取的就是忽略异常，最好记录异常日志，然后处理或向上抛出。
#### 057. Java 中异常处理关键字
&#8195;&#8195;Java 中异常处理关键字有：`throws`、`throw`、`try`、`catch`、`finally`。
- `try`：用来指定一块预防所有异常的程序块。
- `catch`：紧跟在`try`语句块后边，用来指定想要捕获的异常类型。
- `finally`：为确保一段代码不管正常执行完成还是出现任何异常，都能被执行。
- `throw`：用来明确地抛出异常异常。
- `throws`：用来声明一个方法可能抛出的各种异常。
#### 058. 异常链
&#8195;&#8195;异常链是 Java 中非常流行的异常处理概念，是指在进行一个异常处理时抛出了另外一个异常，由此产生了一个异常链条。该技术大多用于将受检异常封装成为非受检异常。抛出一个新异常时一定要包含原有的异常，这样，处理程序才可以通过`getCause()`和`initCause()`方法来访问异常的根源。
#### 059. `try-with-resources`
&#8195;&#8195;Java 中对于文件操作 IO 流、数据库连接等开销非常昂贵的资源，用完之后必须及时通过`close()`方法将其关闭，否则资源会一直处于打开状态，可能会导致内存泄漏等问题，关闭资源的常用方式就是在`finally`块里调用`close()`方法释放。从 JDK 1.7 开始，提供了一种更优雅的方式关闭资源，即`try-with-resources`，例如，`try(BufferedReader br = new BufferedReader(...))`，那些繁琐的关闭资源的操作，由编译器做了。需要注意，通过这种方式打开的资源类必须实现了`AutoCloseable`接口。

&#8195;&#8195;除了`try-with-resources`之外，JDK 1.7 对异常还提供了以下优化：
- `Multi-Catch Exceptions`：如果对于多个异常使用相同的处理逻辑来处理，可采用形如`catch(ParseException | IOException exception)`的方式。
- `Rethrowing Exceptions`：JDK 1.7 以前，在`catch`块中想把异常直接抛出时，直接`throw e;`是编译错误的，必须`throw new RuntimeException(e);`这样包装一下，但这已经不是原来的异常了。JDK 1.7 允许了在`catch`中`Rethrowing Exceptions`。
- `Suppressed Exceptions`：用来保存被屏蔽的异常，可通过`Throwable.getSuppressed()`获得。添加的话用`addSuppressed(Throwable exception)`，这个函数一般是在`try-with-resources`语句中自动调用的。
#### 060. Java 的序列化和反序列化
&#8195;&#8195;序列化是指将对象的状态信息转换为可存储或可传输格式的过程，一般是以字节码或者 XML 编码格式传输，而字节码或 XML 编码格式可以还原为完全相等的对象，这个相反的过程称为反序列化，反序列化是序列化的逆操作。
- Java 对象的序列化：Java 平台允许我们在内存中创建可复用的 Java 对象，但一般情况下，只有当 JVM 处于运行状态，这些对象才可能存在，它们的生命周期不会比 JVM 的生命周期更长。但在现实应用中，就可能要求在 JVM 停止运行之后能够保存（持久化）指定的对象，并在将来重新读取被保存的对象。Java 对象序列化就能够帮我们实现该功能，使用 Java 对象序列化，在保存对象时，会把其状态保存为一组字节，在未来再将这些字节组装成对象。必须注意地是，对象序列化保存的是对象的“状态”，即它的成员变量。由此可知，**对象序列化不会关注类中的静态变量**。除了在持久化对象时会用到对象序列化之外，当使用 RMI（远程方法调用）或在网络中传递对象时，都会用到对象序列化。
- 如果对 Java 对象进行序列化与反序列化：Java 序列化 API 为处理对象序列化提供了一个标准机制，该 API 简单易用。
  - 在 Java 中只要一个类实现了`java.io.Serializable`接口，那么它就可以被序列化。
  - 通过`ObjectOutputStream`和`ObjectInputStream`对对象进行序列化及反序列化。
  - 虚拟机是否允许反序列化，不仅取决于类路径和功能代码是否一致，一个非常重要的一点是两个类的序列化 ID（`private static final long serialVersionUID`）是否一致。
  - 序列化并不保存静态变量。
  - 要想将父类对象也序列化，就需要让父类也实现`Serializable`接口。
  - `transient`关键字的作用是控制变量的序列化，在变量声明前加上该关键字，可以阻止该变量被序列化到文件中，在被反序列化后，`transient`变量被设为初始值。
  - 服务器端给客户端发送序列化对象数据，对象中有一些数据是敏感的，比如密码字符串等，希望对该密码字段在序列化时进行加密，而客户端如果拥有解密的密钥，只有在客户端进行反序列化时，才可以对密码进行读取，这样可以一定程度上保证序列化对象的数据安全。
- `ArrayList`中的序列化
  - `writeObject`和`readObject`方法：在序列化过程中，如果被序列化的类中定义了`writeObject`和`readObject`方法，虚拟机会试图调用对象类里的`writeObject`和`readObject`方法，进行用户自定义的序列化和反序列化，否则默认调用的是`ObjectOutputStream`的`defaultWriteObject`方法和`ObjectInputStream`的`defaultReadObject`方法。用户自定义的`writeObject`和`readObject`方法可以允许用户控制序列化的过程，比如可以在序列化的过程中动态改变序列化的数值。
  - why `transient`：`ArrayList`实际上是动态数组，每次在放满以后自动增长设定的长度值，如果数组自动增长长度设为 100，而实际只放了一个元素，那就会序列化 99 个`null`元素。为了保证在序列化的时候不会将这么多`null`同时进行序列化，`ArrayList`把元素数组`elementData`设置为`transient`。
  - why `writeObject` and `readObject`：由于使用`transient`来声明`elementData`，但作为一个集合，在序列化过程中还必须保证其中的元素可以被持久化下来，所以，通过重写`writeObject`和`readObject`方法的方式把其中的元素保留下来。`writeObject`方法把`elementData`数组中的元素遍历地保存到输出流（`ObjectOutputStream`）中；`readObject`方法从输入流（`ObjectInputStream`）中读出对象并保存赋值到`elementData`数组中。
  - `ObjectOutputStream`：`ObjectOutputStream`的`writeObject`的调用栈：`writeObject --> writeObject0 --> writeOrdinaryObject --> writeSerialData --> invokeWriteObject`。
```
     void invokeWriteObject(Object obj, ObjectOutputStream out)
          throws IOException, UnsupportedOperationException
      {
          requireInitialized();
          if (writeObjectMethod != null) {
              try {
                  writeObjectMethod.invoke(obj, new Object[]{ out });
              } catch (InvocationTargetException ex) {
                  Throwable th = ex.getTargetException();
                  if (th instanceof IOException) {
                      throw (IOException) th;
                  } else {
                      throwMiscException(th);
                  }
              } catch (IllegalAccessException ex) {
                  // should not occur, as access checks have been suppressed
                  throw new InternalError(ex);
              }
          } else {
              throw new UnsupportedOperationException();
          }
      }
```

&#8195;&#8195;其中`writeObjectMethod.invoke(obj, new Object[]{ out });`是关键，通过反射的方式调用`writeObjectMethod`（`class-defined writeObject method, or null if none`）方法，也就是自定义的`writeObject`方法。
- 如何保证实现了`Serializable`接口的类的序列化与反序列化：`Serializable`虽然是一个空接口，但尝试序列化未实现该接口的类时，会抛出`java.io.NotSerializableException`，这是因为`ObjectOutputStream`的`writeObject`的调用栈中`writeObject0`方法中会判断要被序列化的类是否是`Enum`、`Array`和`Serializable`类型，如果不是则直接抛出`java.io.NotSerializableException`。
```
      if (obj instanceof String) {
          writeString((String) obj, unshared);
      } else if (cl.isArray()) {
          writeArray(obj, desc, unshared);
      } else if (obj instanceof Enum) {
          writeEnum((Enum<?>) obj, desc, unshared);
      } else if (obj instanceof Serializable) {
          writeOrdinaryObject(obj, desc, unshared);
      } else {
          if (extendedDebugInfo) {
              throw new NotSerializableException(
                  cl.getName() + "\n" + debugInfoStack.toString());
          } else {
              throw new NotSerializableException(cl.getName());
          }
      }
```
- **总结**
  1. 如果一个类想被序列化，需要实现`Serializable`接口。否则将抛出`NotSerializableException`异常，这是因为，在序列化操作过程中会对类型进行检查，要求被序列化的类必须属于`Enum`、`Array`和`Serializable`类型其中的任何一种。
  2. 在变量声明前加上`transient`关键字，可以阻止该变量被序列化到文件中。
  3. 在类中增加`writeObject`和`readObject`方法可以实现自定义序列化策略
#### 061. `Serializable` VS `Externalizable`
&#8195;&#8195;`Serializable`接口没有方法或字段，仅用于标识可序列化的语义。`Externalizable`接口继承了`Serializable`接口，该接口中定义了两个抽象方法：`writeExternal()`和`readExternal()`，当使用`Externalizable`接口来进行序列化与反序列化时需要开发人员重写`writeExternal()`和`readExternal()`方法。如果没有在这两个方法中定义序列化实现细节，那么序列化之后，对象内容为空。实现`Externalizable`接口的类必须提供一个`public`的无参构造器。实现`Externalizable`，并实现`writeExternal()`和`readExternal()`方法可以指定序列化哪些属性。
#### 062. `serialVersionUID`的作用
&#8195;&#8195;在进行反序列化时，JVM 会把传来的字节流中的`serialVersionUID`与本地相应实体类的`serialVersionUID`进行比较，如果相同就认为是一致的，可以进行反序列化，否则就会出现序列化版本不一致的异常，即`InvalidCastException`，这样是为了保证安全，防止文件存储中的内容被篡改。

&#8195;&#8195;当实现`Serializable`接口的类没有显式地定义一个`serialVersionUID`时，Java 序列化机制会根据编译的 Class 自动生成一个`serialVersionUID`作序列化版本比较使用，这种情况下，如果 Class 文件没有发生变化，就算编译多次，`serialVersionUID`也不会变化的，但 Class 文件一旦发生变化，对应的`serialVersionUID`也就会发生变化。

&#8195;&#8195;基于以上原理，如果一个类实现了`Serializable`接口，但是没有定义`serialVersionUID`，然后序列化。序列化之后，出于某些原因修改了这个类并重新编译启动后，对之前序列化过的对象进行反序列化时就会报错。只要在类中定义了`serialVersionUID`，后续修改这个类（比如新增一个属性）不会导致序列化失败（新增的属性在反序列化后会为默认值，如`null`）。
#### 063. 常用的 Java 序列化框架
&#8195;&#8195;常用的 Java 序列化框架有`Java`、`Kryo`、`Hessian`、`Protostuff`、`gson`、`fastjson`等。
- `Kryo`：速度快，序列化后体积小；跨语言支持较复杂。
- `Hessian`：默认支持跨语言；效率不高。
- `Protostuff`：速度快，基于`Protobuf`；需要静态编译。
- `Protostuff-Runtime`：无需静态编译，但序列化前需预先传入`schema`；不支持无默认构造函数的类，反序列化时需要用户自己初始化序列化后的对象，其只负责将该对象进行赋值。
- `Java`：使用方便，可序列化所有类；速度慢，占空间。
#### 064. 序列化的安全性问题

&#8195;&#8195;
