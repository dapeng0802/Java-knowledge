#### 029. Java 集合类框架图
![Java 集合框架图](http://image.bubuko.com/info/201802/20180201100829255445.png)
#### 030. `Collection` VS `Collections`
&#8195;&#8195;`Collection`是一个集合接口，它提供了对集合对象进行基本操作的通用接口方法。`Collection`接口在 Java 类库中有很多具体的实现，也是`List`、`Set`等接口的父接口。

&#8195;&#8195;`Collections`是一个包装类，它包含有各种有关集合操作的静态多态方法。此类不能被实例化，就像一个工具类，服务于 Java 的`Collection`框架，使用`Collections`类可以提升很多处理集合类的效率。
#### 031. `Set` VS `List`
&#8195;&#8195;`Set`和`List`都`extends`自`Collection`接口，都用来存储一组相同类型的元素。`List`的特点是：元素有放入顺序，元素可重复。`Set`的特点是：元素无放入顺序，元素不可重复。有些场景下，`Set`可以用来去重，不过`Set`在元素插入时要有一定的方法来判断元素是否重复，这个方法很重要，决定了`Set`中可以保存哪些元素。
#### 032. `Set`如何保证元素不重复
&#8195;&#8195;在 Java 的`Set`体系中，根据实现方式不同主要分为两大类：`HashSet`和`TreeSet`。
1. `TreeSet`是二叉树实现的，`TreeSet`中的数据是自动排好序的，不允许放入`null`值。
2. `HashSet`是哈希表是实现的，`HashSet`中的数据是无序的，可以放入`null`，但只能放入一个`null`。

&#8195;&#8195;在`HashSet`中，基本的操作都是由`HashMap`底层实现的，因为`HashSet`底层是用`HashMap`存储数据的。当向`HashSet`中添加元素时，实际通过`map.put(e, PRESENT)`调用`HashMap`的`put`方法，首先计算元素的`hashcode`，然后通过扰动计算和按位与的方式计算出这个元素的存储位置，如果这个位置为空，就将元素添加进去，如果不为空，则用`equals`方法比较元素是否相等，相等就不添加，否则找一个空位（链表或红黑树）添加。

&#8195;&#8195;`TreeSet`的底层时`TreeMap`的`keySet()`，而`TreeMap`时基于红黑树实现的，红黑树时一种平衡二叉查找树，它能保证任何一个节点的左右子树的高度差不会超过较矮那棵子树的一倍。`TreeMap`是按`key`排序的，元素在插入`TreeSet`时`compareTo()`方法要被调用，所以`TreeSet`中的元素要实现`Comparable`接口，`TreeSet`是用`compareTo()`方法来判断重复元素的。
#### 033. Java 中`List`的几种实现
&#8195;&#8195;`List`主要有`ArrayList`、`LinkedList`与`Vector`几种实现。这三者都实现了`List`接口，使用方式也很相似，主要区别在于实现方式不同，因此对不同的操作具有不同的效率。
- `ArrayList`是一个可改变大小的**数组**，当更多的元素加入到`ArrayList`中时，其大小将会动态地增长，内部的元素可以直接通过`get`与`set`方法进行访问，因为`ArrayList`本质上就是一个数组。
- `LinkedList`时一个**双链表**，在添加和删除元素时具有比`ArrayList`更好的性能，但在`get`与`set`方面弱于`ArrayList`，当然这些对比都是指数据量很大或者操作很频繁的情况下的对比，如果数据和运算量很小，那么对比将失去意义。`LinkedList`还实现了`Queue`接口，该接口比`List`提供了更多的方法，包括`offer()`、`peek()`、`poll()`等。
- `Vector`和`ArrayList`类似，但属于**强同步类**。如果程序本身时线程安全的则使用`ArrayList`是更好的选择。`Vector`和`ArrayList`在更多元素添加进来时会请求更大的空间，`Vector`每次扩容增长至其大小的 2 倍空间，而`ArrayList`每次扩容对`size`增长至 1.5 倍。

&#8195;&#8195;注意：默认情况下`ArrayList`的初始容量非常小，如果可以预估数据量的话，分配一个较大的初始值可以减少调整大小的开销，属于最佳实践。
#### 034. `SynchronizedList` VS `Vector`
&#8195;&#8195;`Vector`是`java.util`包中的一个类，`SynchronizedList`是`java.util.Collections`类中的一个静态内部类。在多线程的场景中可以直接使用`Vector`类，也可以使用`Collections.synchronizedList(List list)`方法来返回一个线程安全的`List`。
1. 如果使用`add`方法，那么它们的扩容机制不一样。
2. `SynchronizedList`可以指定锁定的对象（通过`Object mutex`指定，不指定时默认为`this`），即锁粒度是同步代码块。而`Vector`的锁粒度是同步方法。
3. `SynchronizedList`有很好的扩展和兼容功能，它可以将所有的`List`的子类转成线程安全的类。
4. 使用`SynchronizedList`的时候，进行遍历时要手动进行同步处理（`SynchronizedList`中对`listIterator`和`listIterator(int index)`没有做同步处理）。
#### 035. 通过`Arrays.asList`获得的`List`有何特点？
&#8195;&#8195;`asList`得到的只是一个`Arrays`的内部类：`private static class ArrayList<E> extends AbstractList<E>`，一个原来数组的视图`List`，因此如果对它进行增删操作会报错。用`java.util.ArrayList`的构造函数可以将其转变成真正的`java.util.ArrayList`。 
#### 036. Java 中`Collection`的迭代方式
1. 传统的`for`循环遍历，基于计数器的：维护一个计数器，然后依次读取每个位置的元素，当读取到最后一个元素后，停止。主要就是需要按元素的位置来读取元素。
2. `Iterator`迭代器遍历：每一个具体实现的数据集合，一般都需要提供相应的`Iterator`。相比于传统`for`循环，`Iterator`取缔了显示的遍历计数器，所以基于顺序存储集合的`Iterator`可以直接按位置访问数据。而基于链式存储集合的`Iterator`，正常的实现，都是需要保存当前遍历的位置，然后根据当前位置来向前或者向后移动指针。
3. `forEach`循环遍历：根据反编译字节码可以知道，`forEach`内部也是采用了`Iterator`的方式实现的，只不过 Java 编译器帮我们生成了这些代码。
4. `Enumeration`迭代器遍历：`Enumeration`接口是`Iterator`迭代器的“古老版本”，从 JDK 1.0 开始，`Enumeration`接口就已经存在了，`Iterator`从 JDK 1.2 才出现。
#### 037. `Enumeration`接口 VS `Iterator`接口
- 接口函数不同：`Enumeration`接口只提供`hasMoreElements`和`nextElement`两个函数定义，因此只能读取集合的数据，而不能对数据进行修改；`Iterator`接口提供`hasNext`、`next`、`remove`以及 JDK 1.8 增加的`forEachRemaining`函数定义，因此`Iterator`除了能读取集合的数据之外，也能对数据进行删除操作。
- `Iterator`支持`fail-fast`机制，而`Enumeration`不支持。`Enumeration`是 JDK 1.0 添加的接口，使用到它的函数包括`Vector`、`Hashtable`等 JDK 1.0 中加入的类，`Enumeration`存在的目的就是为它们提供遍历接口，本身并没有支持同步，在`Vector`、`Hashtable`实现时添加了同步；而`Iterator`是 JDK 1.2 才添加的接口，它也是为了`HashMap`、`ArrayList`等集合提供遍历接口，`Iterator`支持`fail-fast`机制：当多个线程对同一个集合的内容进行操作时，就可能会产生`fail-fast`事件。

&#8195;&#8195;注意：`Enumeration`迭代器只能遍历`Vector`、`Hashtable`这种古老的集合，因此通常不要使用它，除非在某些极端情况下，不得不使用，否则都应该选择`Iterator`迭代器。
#### 038. `Iterator`接口 VS `ListIterator`接口
- `Iterator`接口可用于遍历`Set`、`List`，`ListIterator`接口只可用于遍历`List`。
- `Iterator`接口只能向后遍历（`hasNext()`、`next()`），`ListIterator`接口可以向前或向后遍历（`hasNext()`、`next()`、`hasPrevious()`、`previous()`）。
- `ListIterator`接口继承自`Iterator`接口，并增加了：
  - `add()`方法，可向`List`添加对象
  - `set()`方法，可修改对象
  - `nextindex()`和`previousIndex()`方法，定位索引位置
#### 039. fail-fast VS fail-safe
&#8195;&#8195;_**快速失败（fail-fast）**_

&#8195;&#8195;在使用迭代器遍历一个集合对象时，如果遍历过程中对集合对象的内容进行了修改（增加、删除、修改），则会抛出`ConcurrentModificationException`。fail-fast 的原理：迭代器在遍历时直接访问集合中的内容，并且在遍历过程中使用一个`modCount`变量。集合在遍历期间如果内容发生变化，就会改变`modCount`的值。每当迭代器使用`hasNext()`/`next()`遍历下一个元素之前，都会检测`modCount`变量是否为`expectedModCount`值，是的话就继续遍历，否则抛出异常，终止遍历。需要注意的是，异常的抛出的检测条件是`expectedModCount == modCount`，如果集合发生变化时修改`modCount`值刚好又设置为同`expectedModCount`相等的值，则异常不会抛出，因此，不能依赖于这个异常是否抛出而进行并发编程的控制条件，这个异常只建议用于检测并发修改的 bug。`java.util`包下的集合类都是 fail-fast 的，不能在多线程下发生并发修改。
 
&#8195;&#8195;_**安全失败（fail-safe）**_

&#8195;&#8195;采用 fail-safe 机制的集合容器，在遍历时不是直接在集合内容上访问的，而是先复制原有集合内容，在拷贝的集合上进行遍历。fail-safe 的原理：由于迭代时是对集合的拷贝进行遍历，所以在遍历过程中对原集合所作的修改并不能被迭代器检测到，所以不会触发`ConcurrentModificationException`。基于拷贝内容的优点时避免了`ConcurrentModificationException`，但同样存在缺点，迭代器不能访问到修改后的内容，即：迭代器遍历的时开始遍历那一刻拿到的集合拷贝，在遍历期间原集合发生的修改迭代器是不知道的。`java.util.concurrent`包下的容器都是 fail-safe 的，可以在多线程下并发使用、并发修改。
#### 040. 如何在遍历的同时删除`ArrayList`中的元素？


&#8195;&#8195;
&#8195;&#8195;
